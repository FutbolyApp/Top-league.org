import express from 'express';
import { requireAuth } from '../middleware/auth.js';
import { getDb } from '../db/config.js';
import { 
  testScraping, 
  scrapeClassifica, 
  scrapeRisultati, 
  scrapeCalciatori,
  scrapeVoti,
  updateClassificaFromScraping,
  updateVotiFromScraping,
  importCalciatoriFromScraping
} from '../utils/scraper.js';

// Importa il nuovo scraper Puppeteer
import FantacalcioScraper from '../utils/scraperPuppeteer.js';
import { testCredentialsWithPuppeteer } from '../utils/scraperPuppeteer.js';

// Importa il nuovo scraper Playwright
import PlaywrightScraper from '../utils/playwrightScraper.js';

const router = express.Router();
const db = getDb();

// Test scraping per un URL
router.post('/test', requireAuth, async (req, res) => {
  try {
    const { url } = req.body;
    
    if (!url) {
      return res.status(400).json({ error: 'URL richiesto' });
    }
    
    const result = await testScraping(url);
    res.json(result);
    
  } catch (error) {
    console.error('Errore test scraping:', error);
    res.status(500).json({ error: 'Errore nel test dello scraping' });
  }
});

// Nuovo endpoint per scraping con Puppeteer (login richiesto)
router.post('/puppeteer/league', requireAuth, async (req, res) => {
  try {
    const { 
      leagueUrl, 
      scrapingUrls,
      username, 
      password, 
      tournamentId = null,
      lega_id = null
    } = req.body;
    
    if (!leagueUrl || !username || !password) {
      return res.status(400).json({ 
        error: 'leagueUrl, username e password sono richiesti' 
      });
    }
    
    console.log(`Avvio scraping Puppeteer per: ${leagueUrl}`);
    console.log(`Username ricevuto: ${username}`);
    console.log(`Password ricevuta: ${password}`);
    console.log(`URL di scraping:`, scrapingUrls);
    console.log(`Dettagli richiesta:`, {
      leagueUrl,
      scrapingUrls,
      username,
      password: password ? '***' : 'MISSING',
      tournamentId,
      lega_id,
      userId: req.user.id,
      timestamp: new Date().toISOString()
    });
    
    const scraper = new FantacalcioScraper();
    
    try {
      const results = await scraper.scrapeLeague(
        leagueUrl,
        scrapingUrls,
        { username, password },
        tournamentId,
        lega_id
      );
      
      if (results) {
        console.log('Scraping completato con successo');
        
        let message = 'Scraping completato con successo';
        if (results.database) {
          message += `. Salvati nel database: ${results.database.squadre_salvate} squadre, ${results.database.giocatori_salvati} giocatori`;
        }
        
        res.json({ 
          success: true, 
          message: message,
          data: results 
        });
      } else {
        console.log('Scraping fallito - risultati nulli');
        res.json({ 
          success: false, 
          error: 'Scraping fallito - controlla le credenziali e l\'URL',
          message: 'Le credenziali potrebbero essere errate o l\'URL non √® valido'
        });
      }
    } catch (scrapingError) {
      console.error('Errore durante lo scraping:', scrapingError);
      res.json({ 
        success: false,
        error: 'Errore durante lo scraping: ' + scrapingError.message,
        message: 'Si √® verificato un errore durante il processo di scraping'
      });
    }
    
  } catch (error) {
    console.error('Errore generale scraping Puppeteer:', error);
    res.json({ 
      success: false,
      error: 'Errore durante lo scraping: ' + error.message,
      message: 'Si √® verificato un errore generale nel sistema di scraping'
    });
  }
});

// NUOVO ENDPOINT: Scraping con login manuale
router.post('/puppeteer/manual-login', requireAuth, async (req, res) => {
  try {
    const { 
      leagueUrl, 
      scrapingUrls,
      username, 
      password, 
      tournamentId = null,
      lega_id = null
    } = req.body;
    
    if (!leagueUrl) {
      return res.status(400).json({ 
        error: 'leagueUrl √® richiesto' 
      });
    }
    
    console.log(`üöÄ Avvio scraping con login manuale per: ${leagueUrl}`);
    console.log(`üåê URL di scraping:`, scrapingUrls);
    console.log(`üìä Dettagli richiesta:`, {
      leagueUrl,
      scrapingUrls,
      username: username || 'NON RICHIESTO',
      password: password ? '***' : 'NON RICHIESTO',
      tournamentId,
      lega_id,
      userId: req.user.id,
      timestamp: new Date().toISOString()
    });
    
    const scraper = new FantacalcioScraper();
    
    try {
      const results = await scraper.scrapeLeagueWithManualLogin(
        leagueUrl, 
        scrapingUrls, 
        { username: username || '', password: password || '' }, 
        tournamentId, 
        lega_id
      );
      
      if (results) {
        console.log('‚úÖ Scraping con login manuale completato con successo');
        
        let message = 'Scraping con login manuale completato con successo';
        if (results.database) {
          message += `. Salvati nel database: ${results.database.squadre_salvate} squadre, ${results.database.giocatori_salvati} giocatori`;
        }
        
        res.json({ 
          success: true, 
          message: message,
          data: results 
        });
      } else {
        console.log('‚ùå Scraping con login manuale fallito - risultati nulli');
        res.json({ 
          success: false, 
          error: 'Scraping fallito - controlla l\'URL e il processo di login',
          message: 'Il processo di scraping non √® riuscito a completarsi'
        });
      }
    } catch (scrapingError) {
      console.error('‚ùå Errore durante lo scraping con login manuale:', scrapingError);
      res.json({ 
        success: false,
        error: 'Errore durante lo scraping: ' + scrapingError.message,
        message: 'Si √® verificato un errore durante il processo di scraping con login manuale'
      });
    }
    
  } catch (error) {
    console.error('‚ùå Errore generale scraping con login manuale:', error);
    res.json({ 
      success: false,
      error: 'Errore durante lo scraping: ' + error.message,
      message: 'Si √® verificato un errore generale nel sistema di scraping con login manuale'
    });
  }
});

// Endpoint per aggiornare credenziali di una lega
router.post('/update-credentials', requireAuth, async (req, res) => {
  try {
    const { 
      lega_id, 
      username, 
      password 
    } = req.body;
    
    if (!lega_id || !username || !password) {
      return res.status(400).json({ 
        error: 'lega_id, username e password sono richiesti' 
      });
    }
    
    console.log(`üîê Aggiornamento credenziali per lega ${lega_id}`);
    
    // Aggiorna le credenziali nel database
    const db = getDb();
    
    db.run(
      `UPDATE leghe 
       SET fantacalcio_username = ?, fantacalcio_password = ?, updated_at = datetime('now')
       WHERE id = ?`,
      [username, password, lega_id],
      function(err) {
        if (err) {
          console.error('‚ùå Errore aggiornamento credenziali:', err);
          return res.status(500).json({ 
            error: 'Errore nell\'aggiornamento delle credenziali nel database' 
          });
        }
        
        if (this.changes === 0) {
          return res.status(404).json({ 
            error: 'Lega non trovata' 
          });
        }
        
        console.log('‚úÖ Credenziali aggiornate con successo');
    res.json({ 
      success: true, 
          message: 'Credenziali aggiornate con successo',
          lega_id: lega_id
    });
      }
    );
    
  } catch (error) {
    console.error('‚ùå Errore aggiornamento credenziali:', error);
    res.status(500).json({ 
      error: 'Errore nell\'aggiornamento delle credenziali' 
    });
  }
});

// Endpoint per avviare scraping automatico (ogni 3 ore)
router.post('/start-auto-scraping', requireAuth, async (req, res) => {
  try {
    const { lega_id } = req.body;
    
    if (!lega_id) {
      return res.status(400).json({ error: 'lega_id richiesto' });
    }
    
    // TODO: Implementa il cron job per lo scraping automatico
    // Per ora restituisce successo
    res.json({ 
      success: true, 
      message: 'Scraping automatico avviato (ogni 3 ore)' 
    });
    
  } catch (error) {
    console.error('Errore avvio scraping automatico:', error);
    res.status(500).json({ 
      error: 'Errore nell\'avvio dello scraping automatico' 
    });
  }
});

// Endpoint per fermare scraping automatico
router.post('/stop-auto-scraping', requireAuth, async (req, res) => {
  try {
    const { lega_id } = req.body;
    
    if (!lega_id) {
      return res.status(400).json({ error: 'lega_id richiesto' });
    }
    
    // TODO: Ferma il cron job per lo scraping automatico
    res.json({ 
      success: true, 
      message: 'Scraping automatico fermato' 
    });
    
  } catch (error) {
    console.error('Errore stop scraping automatico:', error);
    res.status(500).json({ 
      error: 'Errore nel fermare lo scraping automatico' 
    });
  }
});

// Scraping classifica
router.post('/classifica', requireAuth, async (req, res) => {
  try {
    const { url, lega_id } = req.body;
    
    if (!url || !lega_id) {
      return res.status(400).json({ error: 'URL e lega_id richiesti' });
    }
    
    const classifica = await scrapeClassifica(url);
    res.json({ success: true, classifica });
    
  } catch (error) {
    console.error('Errore scraping classifica:', error);
    res.status(500).json({ error: 'Errore nel scraping della classifica' });
  }
});

// Scraping risultati
router.post('/risultati', requireAuth, async (req, res) => {
  try {
    const { url } = req.body;
    
    if (!url) {
      return res.status(400).json({ error: 'URL richiesto' });
    }
    
    const risultati = await scrapeRisultati(url);
    res.json({ success: true, risultati });
    
  } catch (error) {
    console.error('Errore scraping risultati:', error);
    res.status(500).json({ error: 'Errore nel scraping dei risultati' });
  }
});

// Scraping calciatori
router.post('/calciatori', requireAuth, async (req, res) => {
  try {
    const { url } = req.body;
    
    if (!url) {
      return res.status(400).json({ error: 'URL richiesto' });
    }
    
    const calciatori = await scrapeCalciatori(url);
    res.json({ success: true, calciatori });
    
  } catch (error) {
    console.error('Errore scraping calciatori:', error);
    res.status(500).json({ error: 'Errore nel scraping dei calciatori' });
  }
});

// Scraping voti
router.post('/voti', requireAuth, async (req, res) => {
  try {
    const { url } = req.body;
    
    if (!url) {
      return res.status(400).json({ error: 'URL richiesto' });
    }
    
    const voti = await scrapeVoti(url);
    res.json({ success: true, voti });
    
  } catch (error) {
    console.error('Errore scraping voti:', error);
    res.status(500).json({ error: 'Errore nel scraping dei voti' });
  }
});

// Aggiorna classifica nel database
router.post('/update-classifica', requireAuth, async (req, res) => {
  try {
    const { url, lega_id } = req.body;
    
    if (!url || !lega_id) {
      return res.status(400).json({ error: 'URL e lega_id richiesti' });
    }
    
    const result = await updateClassificaFromScraping(lega_id, url);
    res.json(result);
    
  } catch (error) {
    console.error('Errore aggiornamento classifica:', error);
    res.status(500).json({ error: 'Errore nell\'aggiornamento della classifica' });
  }
});

// Aggiorna voti nel database
router.post('/update-voti', requireAuth, async (req, res) => {
  try {
    const { url, lega_id } = req.body;
    
    if (!url || !lega_id) {
      return res.status(400).json({ error: 'URL e lega_id richiesti' });
    }
    
    const result = await updateVotiFromScraping(lega_id, url);
    res.json(result);
    
  } catch (error) {
    console.error('Errore aggiornamento voti:', error);
    res.status(500).json({ error: 'Errore nell\'aggiornamento dei voti' });
  }
});

// Importa calciatori nel database
router.post('/import-calciatori', requireAuth, async (req, res) => {
  try {
    const { url, lega_id } = req.body;
    
    if (!url || !lega_id) {
      return res.status(400).json({ error: 'URL e lega_id richiesti' });
    }
    
    const result = await importCalciatoriFromScraping(lega_id, url);
    res.json(result);
    
  } catch (error) {
    console.error('Errore importazione calciatori:', error);
    res.status(500).json({ error: 'Errore nell\'importazione dei calciatori' });
  }
});

// Scraping completo per una lega
router.post('/completo', requireAuth, async (req, res) => {
  try {
    const { 
      lega_id, 
      classifica_url, 
      voti_url, 
      calciatori_url 
    } = req.body;
    
    if (!lega_id) {
      return res.status(400).json({ error: 'lega_id richiesto' });
    }
    
    const results = {};
    
    // Scraping classifica se fornito URL
    if (classifica_url) {
      try {
        results.classifica = await updateClassificaFromScraping(lega_id, classifica_url);
      } catch (error) {
        results.classifica = { error: error.message };
      }
    }
    
    // Scraping voti se fornito URL
    if (voti_url) {
      try {
        results.voti = await updateVotiFromScraping(lega_id, voti_url);
      } catch (error) {
        results.voti = { error: error.message };
      }
    }
    
    // Scraping calciatori se fornito URL
    if (calciatori_url) {
      try {
        results.calciatori = await importCalciatoriFromScraping(lega_id, calciatori_url);
      } catch (error) {
        results.calciatori = { error: error.message };
      }
    }
    
    res.json({ success: true, results });
    
  } catch (error) {
    console.error('Errore scraping completo:', error);
    res.status(500).json({ error: 'Errore nel scraping completo' });
  }
});

// Test manuale delle credenziali
router.post('/test-credentials', requireAuth, async (req, res) => {
    try {
        const { leagueId, username, password } = req.body;
        
        if (!leagueId || !username || !password) {
            return res.status(400).json({
                success: false,
                message: 'League ID, username e password sono richiesti'
            });
        }

        console.log('üß™ TEST MANUALE CREDENZIALI:');
        console.log('League ID:', leagueId);
        console.log('Username:', username);
        console.log('Password:', '***');

        const scraper = new FantacalcioScraper();
        
        try {
            // Usa il nuovo metodo per testare solo le credenziali
            const result = await scraper.testCredentialsOnly(username, password);
            
            return res.json(result);

        } catch (error) {
            console.error('‚ùå Errore test credenziali:', error);
            return res.status(500).json({
                success: false,
                message: `Errore durante il test: ${error.message}`
            });
        }

    } catch (error) {
        console.error('‚ùå Errore endpoint test credenziali:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

// Debug: ottieni credenziali dal database
router.get('/debug-credentials/:leagueId', requireAuth, async (req, res) => {
    try {
        const { leagueId } = req.params;
        const userId = req.user.id;

        console.log('üîç DEBUG: Richiesta credenziali per lega:', leagueId);

        // Verifica che l'utente sia admin della lega
        const lega = await Lega.findOne({
            where: { id: leagueId, admin_id: userId }
        });

        if (!lega) {
            return res.status(404).json({
                success: false,
                message: 'Lega non trovata o non autorizzato'
            });
        }

        console.log('üîç DEBUG: Credenziali trovate:', {
            id: lega.id,
            nome: lega.nome,
            username: lega.fantacalcio_username,
            password: lega.fantacalcio_password ? '***' : 'NON IMPOSTATA',
            hasPassword: !!lega.fantacalcio_password
        });

        res.json({
            success: true,
            data: {
                leagueId: lega.id,
                leagueName: lega.nome,
                username: lega.fantacalcio_username,
                hasPassword: !!lega.fantacalcio_password,
                passwordLength: lega.fantacalcio_password ? lega.fantacalcio_password.length : 0
            }
        });

    } catch (error) {
        console.error('‚ùå Errore debug credenziali:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

// Test URL di scraping
router.post('/test-urls', requireAuth, async (req, res) => {
    try {
        const { leagueUrl } = req.body;
        
        if (!leagueUrl) {
            return res.status(400).json({
                success: false,
                message: 'League URL √® richiesto'
            });
        }

        console.log('üîó TEST URL SCRAPING:', leagueUrl);

        const urlsToTest = [
            { name: 'classifica', url: `${leagueUrl}/classifica` },
            { name: 'voti', url: `${leagueUrl}/voti` },
            { name: 'voti-giornata', url: `${leagueUrl}/voti-giornata` },
            { name: 'calciatori', url: `${leagueUrl}/calciatori` },
            { name: 'rose', url: `${leagueUrl}/rose` },
            { name: 'giocatori', url: `${leagueUrl}/giocatori` },
            { name: 'squadre', url: `${leagueUrl}/squadre` }
        ];

        const results = [];

        for (const urlTest of urlsToTest) {
            try {
                const response = await fetch(urlTest.url, {
                    method: 'HEAD',
                    timeout: 10000
                });
                
                results.push({
                    name: urlTest.name,
                    url: urlTest.url,
                    status: response.status,
                    exists: response.ok
                });
                
                console.log(`‚úÖ ${urlTest.name}: ${response.status} - ${response.ok ? 'ESISTE' : 'NON ESISTE'}`);
                
            } catch (error) {
                results.push({
                    name: urlTest.name,
                    url: urlTest.url,
                    status: 'ERROR',
                    exists: false,
                    error: error.message
                });
                
                console.log(`‚ùå ${urlTest.name}: ERRORE - ${error.message}`);
            }
        }

        const existingUrls = results.filter(r => r.exists);
        const suggestedUrls = {
            classifica: existingUrls.find(r => r.name === 'classifica')?.url || `${leagueUrl}/classifica`,
            voti: existingUrls.find(r => r.name === 'voti' || r.name === 'voti-giornata')?.url || `${leagueUrl}/voti-giornata`,
            calciatori: existingUrls.find(r => r.name === 'rose' || r.name === 'calciatori' || r.name === 'giocatori')?.url || `${leagueUrl}/rose`
        };

        return res.json({
            success: true,
            message: `Test completato - ${existingUrls.length} URL validi trovati`,
            results,
            suggestedUrls
        });

    } catch (error) {
        console.error('‚ùå Errore test URL:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

// Test credenziali con Puppeteer
router.post('/test-credentials-puppeteer', requireAuth, async (req, res) => {
    try {
        const { lega_id, username, password } = req.body;
        if (!lega_id || !username || !password) {
            return res.status(400).json({ success: false, message: 'lega_id, username e password sono richiesti' });
        }
        const result = await testCredentialsWithPuppeteer(username, password);
        res.json(result);
    } catch (error) {
        res.status(500).json({ success: false, message: error.message });
    }
});

// Test URL di scraping con Puppeteer (per siti protetti)
router.post('/test-urls-puppeteer', requireAuth, async (req, res) => {
    try {
        const { leagueUrl, scrapingUrls, username, password } = req.body;
        
        if (!leagueUrl) {
            return res.status(400).json({
                success: false,
                message: 'League URL √® richiesto'
            });
        }
        
        if (!username || !password) {
            return res.status(400).json({ 
                success: false, 
                message: 'Username e password sono richiesti per testare URL protetti'
            });
        }

        console.log('üîó TEST URL SCRAPING CON PUPPETEER:', leagueUrl);
        console.log('üåê URL di scraping da testare:', scrapingUrls);

        const scraper = new FantacalcioScraper();
        
        try {
            // Testa tutti gli URL di scraping
            const results = await scraper.testUrls(leagueUrl, scrapingUrls, { username, password });
            
            return res.json({
                success: true,
                message: 'Test URL completato con successo',
                data: results
            });
        
    } catch (error) {
            console.error('‚ùå Errore test URL Puppeteer:', error);
            return res.status(500).json({
                success: false,
                message: `Errore durante il test: ${error.message}`
            });
        }

    } catch (error) {
        console.error('‚ùå Errore endpoint test URL Puppeteer:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Errore interno del server'
        });
    }
});

// Endpoint per ottenere i dati di scraping di una lega
router.get('/dati-scraping/:legaId', requireAuth, async (req, res) => {
  try {
    const { legaId } = req.params;
    console.log(`[DEBUG] /dati-scraping/${legaId} - Inizio richiesta`);
    
    // Verifica che l'utente abbia accesso alla lega
    let lega;
    try {
      lega = await new Promise((resolve, reject) => {
        db.get('SELECT * FROM leghe WHERE id = ?', [legaId], (err, row) => {
          if (err) reject(err);
          else resolve(row);
        });
      });
    } catch (err) {
      console.error(`[DEBUG] Errore query lega:`, err);
      return res.status(500).json({ error: 'Errore query lega', details: err.message });
    }
    
    if (!lega) {
      console.warn(`[DEBUG] Lega non trovata: ${legaId}`);
      return res.status(404).json({ error: 'Lega non trovata', legaId });
    }
    
    // Ottieni squadre di scraping
    let squadreScraping;
    try {
      squadreScraping = await new Promise((resolve, reject) => {
        db.all(`
          SELECT id, nome, data_scraping, fonte_scraping 
          FROM squadre_scraping 
          WHERE lega_id = ? 
          ORDER BY nome
        `, [legaId], (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      });
    } catch (err) {
      console.error(`[DEBUG] Errore query squadre_scraping:`, err);
      return res.status(500).json({ error: 'Errore query squadre_scraping', details: err.message });
    }
    
    // Ottieni giocatori di scraping
    let giocatoriScraping;
    try {
      giocatoriScraping = await new Promise((resolve, reject) => {
        db.all(`
          SELECT gs.*, ss.nome as nome_squadra_scraping
          FROM giocatori_scraping gs
          JOIN squadre_scraping ss ON gs.squadra_scraping_id = ss.id
          WHERE gs.lega_id = ?
          ORDER BY ss.nome, gs.nome
        `, [legaId], (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      });
    } catch (err) {
      console.error(`[DEBUG] Errore query giocatori_scraping:`, err);
      return res.status(500).json({ error: 'Errore query giocatori_scraping', details: err.message });
    }
    
    // Raggruppa giocatori per squadra
    const squadreConGiocatori = squadreScraping.map(squadra => ({
      ...squadra,
      giocatori: giocatoriScraping.filter(g => g.squadra_scraping_id === squadra.id)
    }));
    
    // Ottieni classifica di scraping
    let classificaScraping;
    try {
      classificaScraping = await new Promise((resolve, reject) => {
        db.all(`
          SELECT posizione, squadra, punti, partite, vittorie, pareggi, sconfitte, gol_fatti, gol_subiti, differenza_reti, punti_totali, data_scraping
          FROM classifica_scraping 
          WHERE lega_id = ? 
          ORDER BY posizione
        `, [legaId], (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      });
    } catch (err) {
      console.error(`[DEBUG] Errore query classifica_scraping:`, err);
      classificaScraping = [];
    }
    
    // Ottieni voti di scraping
    let votiScraping;
    try {
      votiScraping = await new Promise((resolve, reject) => {
        db.all(`
          SELECT giocatore, voto, squadra, giornata, data_scraping
          FROM voti_scraping 
          WHERE lega_id = ? 
          ORDER BY giornata DESC, voto DESC
        `, [legaId], (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      });
    } catch (err) {
      console.error(`[DEBUG] Errore query voti_scraping:`, err);
      votiScraping = [];
    }
    
    // Ottieni formazioni di scraping
    let formazioniScraping;
    try {
      formazioniScraping = await new Promise((resolve, reject) => {
        db.all(`
          SELECT squadra, modulo, titolari, panchinari, data_scraping
          FROM formazioni_scraping 
          WHERE lega_id = ? 
          ORDER BY squadra
        `, [legaId], (err, rows) => {
          if (err) reject(err);
          else resolve(rows.map(row => ({
            ...row,
            titolari: row.titolari ? JSON.parse(row.titolari) : [],
            panchinari: row.panchinari ? JSON.parse(row.panchinari) : []
          })));
        });
      });
    } catch (err) {
      console.error(`[DEBUG] Errore query formazioni_scraping:`, err);
      formazioniScraping = [];
    }
    
    // Ottieni mercato di scraping
    let mercatoScraping;
    try {
      mercatoScraping = await new Promise((resolve, reject) => {
        db.all(`
          SELECT giocatore, da, a, prezzo, tipo, data_scraping
          FROM mercato_scraping 
          WHERE lega_id = ? 
          ORDER BY data_scraping DESC
        `, [legaId], (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      });
    } catch (err) {
      console.error(`[DEBUG] Errore query mercato_scraping:`, err);
      mercatoScraping = [];
    }
    
    console.log(`[DEBUG] /dati-scraping/${legaId} - Successo, squadre: ${squadreScraping.length}, giocatori: ${giocatoriScraping.length}, classifica: ${classificaScraping.length}, voti: ${votiScraping.length}, formazioni: ${formazioniScraping.length}, mercato: ${mercatoScraping.length}`);
    res.json({
      success: true,
      lega: {
        id: lega.id,
        nome: lega.nome
      },
      dati_scraping: {
        rose: squadreConGiocatori,
        classifica: classificaScraping,
        voti: votiScraping,
        formazioni: formazioniScraping,
        mercato: mercatoScraping,
        totale_squadre: squadreScraping.length,
        totale_giocatori: giocatoriScraping.length,
        totale_posizioni: classificaScraping.length,
        totale_voti: votiScraping.length,
        totale_formazioni: formazioniScraping.length,
        totale_movimenti: mercatoScraping.length,
        ultimo_scraping: squadreScraping.length > 0 ? 
          Math.max(...squadreScraping.map(s => new Date(s.data_scraping).getTime())) : null
      }
    });
    
  } catch (error) {
    console.error('[DEBUG] Errore generico dati-scraping:', error);
    res.status(500).json({ error: 'Errore interno del server', details: error.message });
  }
});

// Endpoint per confrontare dati ufficiali vs scraping
router.get('/confronto/:legaId', requireAuth, async (req, res) => {
  try {
    const { legaId } = req.params;
    console.log(`[DEBUG] /confronto/${legaId} - Inizio richiesta`);
    
    // Verifica che l'utente abbia accesso alla lega
    let lega;
    try {
      lega = await new Promise((resolve, reject) => {
        db.get('SELECT * FROM leghe WHERE id = ?', [legaId], (err, row) => {
          if (err) reject(err);
          else resolve(row);
        });
      });
    } catch (err) {
      console.error(`[DEBUG] Errore query lega:`, err);
      return res.status(500).json({ error: 'Errore query lega', details: err.message });
    }
    
    if (!lega) {
      console.warn(`[DEBUG] Lega non trovata: ${legaId}`);
      return res.status(404).json({ error: 'Lega non trovata', legaId });
    }
    
    // Ottieni squadre ufficiali
    let squadreUfficiali;
    try {
      squadreUfficiali = await new Promise((resolve, reject) => {
        db.all(`
          SELECT id, nome, casse_societarie, valore_squadra 
          FROM squadre 
          WHERE lega_id = ? 
          ORDER BY nome
        `, [legaId], (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      });
    } catch (err) {
      console.error(`[DEBUG] Errore query squadre ufficiali:`, err);
      return res.status(500).json({ error: 'Errore query squadre ufficiali', details: err.message });
    }
    
    // Ottieni giocatori ufficiali
    let giocatoriUfficiali;
    try {
      giocatoriUfficiali = await new Promise((resolve, reject) => {
        db.all(`
          SELECT g.*, s.nome as nome_squadra
          FROM giocatori g
          JOIN squadre s ON g.squadra_id = s.id
          WHERE g.lega_id = ?
          ORDER BY s.nome, g.nome
        `, [legaId], (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      });
    } catch (err) {
      console.error(`[DEBUG] Errore query giocatori ufficiali:`, err);
      return res.status(500).json({ error: 'Errore query giocatori ufficiali', details: err.message });
    }
    
    // Ottieni squadre di scraping
    let squadreScraping;
    try {
      squadreScraping = await new Promise((resolve, reject) => {
        db.all(`
          SELECT id, nome, data_scraping 
          FROM squadre_scraping 
          WHERE lega_id = ? 
          ORDER BY nome
        `, [legaId], (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      });
    } catch (err) {
      console.error(`[DEBUG] Errore query squadre_scraping:`, err);
      return res.status(500).json({ error: 'Errore query squadre_scraping', details: err.message });
    }
    
    // Ottieni giocatori di scraping
    let giocatoriScraping;
    try {
      giocatoriScraping = await new Promise((resolve, reject) => {
        db.all(`
          SELECT gs.*, ss.nome as nome_squadra_scraping
          FROM giocatori_scraping gs
          JOIN squadre_scraping ss ON gs.squadra_scraping_id = ss.id
          WHERE gs.lega_id = ?
          ORDER BY ss.nome, gs.nome
        `, [legaId], (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      });
    } catch (err) {
      console.error(`[DEBUG] Errore query giocatori_scraping:`, err);
      return res.status(500).json({ error: 'Errore query giocatori_scraping', details: err.message });
    }
    
    // Analisi del confronto
    const confronto = {
      squadre_ufficiali: squadreUfficiali.length,
      squadre_scraping: squadreScraping.length,
      giocatori_ufficiali: giocatoriUfficiali.length,
      giocatori_scraping: giocatoriScraping.length,
      squadre_comuni: 0,
      giocatori_comuni: 0,
      differenze: []
    };
    
    // Trova squadre comuni
    const nomiSquadreUfficiali = squadreUfficiali.map(s => s.nome.toLowerCase());
    const nomiSquadreScraping = squadreScraping.map(s => s.nome.toLowerCase());
    
    confronto.squadre_comuni = nomiSquadreUfficiali.filter(nome => 
      nomiSquadreScraping.includes(nome)
    ).length;
    
    // Trova giocatori comuni
    const nomiGiocatoriUfficiali = giocatoriUfficiali.map(g => g.nome.toLowerCase());
    const nomiGiocatoriScraping = giocatoriScraping.map(g => g.nome.toLowerCase());
    
    confronto.giocatori_comuni = nomiGiocatoriUfficiali.filter(nome => 
      nomiGiocatoriScraping.includes(nome)
    ).length;
    
    console.log(`[DEBUG] /confronto/${legaId} - Successo, squadre ufficiali: ${squadreUfficiali.length}, scraping: ${squadreScraping.length}`);
    res.json({
      success: true,
      lega: {
        id: lega.id,
        nome: lega.nome
      },
      confronto,
      dati_ufficiali: {
        squadre: squadreUfficiali,
        giocatori: giocatoriUfficiali
      },
      dati_scraping: {
        squadre: squadreScraping,
        giocatori: giocatoriScraping
      }
    });
    
  } catch (error) {
    console.error('[DEBUG] Errore generico confronto:', error);
    res.status(500).json({ error: 'Errore interno del server', details: error.message });
  }
});

// Debug: analizza struttura pagina
router.post('/debug-page-structure', requireAuth, async (req, res) => {
    try {
        const { url, username, password } = req.body;
        
        if (!url) {
            return res.status(400).json({
                success: false,
                message: 'URL √® richiesto'
            });
        }

        console.log('üîç DEBUG: Analisi struttura pagina:', url);

        const scraper = new FantacalcioScraper();
        
        try {
            if (!await scraper.init()) {
                throw new Error('Impossibile inizializzare il browser Puppeteer');
            }

            // Se sono fornite credenziali, fai login
            if (username && password) {
                if (!await scraper.login(username, password)) {
                    throw new Error('Login fallito - credenziali non valide');
                }
            }

            // Analizza la struttura della pagina
            const structure = await scraper.debugPageStructure(url);
            
            await scraper.close();
            
            return res.json({
                success: true,
                message: 'Struttura pagina analizzata con successo',
                data: structure
            });

        } catch (error) {
            await scraper.close();
            throw error;
        }
        
    } catch (error) {
        console.error('‚ùå Errore debug struttura pagina:', error);
        res.status(500).json({ 
            success: false, 
            message: `Errore durante l'analisi: ${error.message}`
        });
    }
});

// NUOVO ENDPOINT: Scraping con Playwright (frontend)
router.post('/playwright', requireAuth, async (req, res) => {
  try {
    const { 
      leagueUrl, 
      scrapingUrls,
      username, 
      password, 
      tournamentId = null,
      lega_id = null,
      selectedTournament = null,
      tournament = null
    } = req.body;
    
    if (!leagueUrl || !username || !password) {
      return res.status(400).json({ 
        error: 'leagueUrl, username e password sono richiesti' 
      });
    }
    
    console.log('Recupero tornei per lega:', lega_id);
    console.log('URL:', leagueUrl);
    console.log(`Avvio scraping con Playwright per: ${leagueUrl}`);
    console.log(`Username ricevuto: ${username}`);
    console.log(`Password ricevuta: ${password}`);
    console.log(`URL di scraping:`, scrapingUrls);
    console.log(`Torneo selezionato:`, tournament || selectedTournament);
    console.log(`Dettagli richiesta:`, {
      leagueUrl,
      scrapingUrls,
      username,
      password: password ? '***' : 'MISSING',
      tournamentId,
      lega_id,
      tournament: tournament || selectedTournament,
      userId: req.user.id,
      timestamp: new Date().toISOString()
    });
    
    // Importa PlaywrightScraper dal backend
    const { default: PlaywrightScraper } = await import('../utils/playwrightScraper.js');
    const scraper = new PlaywrightScraper();
    
    try {
      const results = await scraper.scrapeLeague(
        leagueUrl,
        scrapingUrls,
        { username, password },
        tournamentId,
        lega_id
      );
      
      if (results) {
        console.log('‚úÖ Scraping con Playwright completato con successo');
        
        // Salva i dati nel database se abbiamo una lega_id e dati validi
        if (lega_id && results) {
          try {
            console.log('üíæ Salvataggio dati nel database...');
            
            // Prima elimina tutti i dati di scraping precedenti
            console.log('üóëÔ∏è Eliminazione dati di scraping precedenti...');
            await scraper.clearAllScrapingData(lega_id);
            
            results.database = {};
            
            // Salva rose
            if (results.rose && Array.isArray(results.rose) && results.rose.length > 0) {
              const roseResults = await scraper.saveRoseToDatabase(lega_id, results.rose);
              results.database.rose = roseResults;
              console.log('‚úÖ Rose salvate nel database:', roseResults);
            }
            
            // Salva classifica
            if (results.classifica && Array.isArray(results.classifica) && results.classifica.length > 0) {
              const classificaResults = await scraper.saveClassificaToDatabase(lega_id, results.classifica);
              results.database.classifica = classificaResults;
              console.log('‚úÖ Classifica salvata nel database:', classificaResults);
            }
            
            // Salva formazioni
            if (results.formazioni && Array.isArray(results.formazioni) && results.formazioni.length > 0) {
              const formazioniResults = await scraper.saveFormazioniToDatabase(lega_id, results.formazioni);
              results.database.formazioni = formazioniResults;
              console.log('‚úÖ Formazioni salvate nel database:', formazioniResults);
            }
            
            console.log('‚úÖ Tutti i dati salvati nel database');
          } catch (dbError) {
            console.error('‚ùå Errore salvataggio database:', dbError);
            results.database = { error: dbError.message };
          }
        }
        
        let message = 'Scraping con Playwright completato con successo';
        if (results.summary) {
          message += `. Trovate: ${results.summary.squadre_trovate} squadre, ${results.summary.giocatori_totali} giocatori`;
        }
        
        if (results.database && results.database.success) {
          message += `. Salvati nel database: ${results.database.squadre_salvate} squadre, ${results.database.giocatori_salvati} giocatori`;
        }
        
        if (tournament || selectedTournament) {
          message += ` (Torneo ID: ${tournament || selectedTournament})`;
        }
        
        res.json({ 
          success: true, 
          message: message,
          data: results 
        });
      } else {
        console.log('‚ùå Scraping con Playwright fallito - risultati nulli');
        res.json({ 
          success: false, 
          error: 'Scraping fallito - controlla le credenziali e l\'URL',
          message: 'Le credenziali potrebbero essere errate o l\'URL non √® valido'
        });
      }
    } catch (scrapingError) {
      console.error('‚ùå Errore durante lo scraping con Playwright:', scrapingError);
      res.json({ 
        success: false,
        error: 'Errore durante lo scraping: ' + scrapingError.message,
        message: 'Si √® verificato un errore durante il processo di scraping con Playwright'
      });
    }
    
  } catch (error) {
    console.error('‚ùå Errore generale scraping con Playwright:', error);
    res.json({ 
      success: false,
      error: 'Errore durante lo scraping: ' + error.message,
      message: 'Si √® verificato un errore generale nel sistema di scraping con Playwright'
    });
  }
});

// NUOVO ENDPOINT: Pulizia profili browser
router.post('/cleanup-profiles', requireAuth, async (req, res) => {
  try {
    console.log('üßπ Richiesta pulizia profili browser...');
    
    // Importa PlaywrightScraper per usare il metodo di pulizia
    const { default: PlaywrightScraper } = await import('../utils/playwrightScraper.js');
    
    // Pulisci i profili Playwright
    await PlaywrightScraper.cleanupAllProfiles();
    
    // Pulisci anche i profili Puppeteer se necessario
    const fs = await import('fs');
    const path = await import('path');
    
    const currentDir = process.cwd();
    const files = fs.readdirSync(currentDir);
    
    const puppeteerProfiles = files.filter(file => 
      file.startsWith('puppeteer_profile') && 
      fs.statSync(path.join(currentDir, file)).isDirectory()
    );
    
    let removedCount = 0;
    
    for (const profile of puppeteerProfiles) {
      try {
        fs.rmSync(path.join(currentDir, profile), { recursive: true, force: true });
        console.log(`‚úÖ Rimosso profilo Puppeteer: ${profile}`);
        removedCount++;
      } catch (error) {
        console.log(`‚ö†Ô∏è Errore rimozione ${profile}: ${error.message}`);
      }
    }
    
    console.log('‚úÖ Pulizia profili completata');
    
    res.json({ 
      success: true, 
      message: 'Pulizia profili browser completata con successo',
      removedProfiles: removedCount
    });
    
  } catch (error) {
    console.error('‚ùå Errore pulizia profili:', error);
    res.json({ 
      success: false,
      error: 'Errore durante la pulizia: ' + error.message
    });
  }
});

// Endpoint di test senza autenticazione
router.get('/test', (req, res) => {
    res.json({ 
        success: true, 
        message: 'Server funzionante',
        timestamp: new Date().toISOString()
    });
});

// NUOVO ENDPOINT: Scraping batch di pi√π tornei con Playwright
router.post('/playwright-batch', requireAuth, async (req, res) => {
  try {
    const { 
      leagueUrl, 
      scrapingUrls,
      username, 
      password, 
      tournamentIds = [],
      lega_id = null
    } = req.body;
    
    if (!leagueUrl || !username || !password) {
      return res.status(400).json({ 
        error: 'leagueUrl, username e password sono richiesti' 
      });
    }
    
    if (!tournamentIds || tournamentIds.length === 0) {
      return res.status(400).json({ 
        error: 'Almeno un tournamentId √® richiesto per lo scraping batch' 
      });
    }
    
    console.log(`Avvio scraping batch con Playwright per ${tournamentIds.length} tornei`);
    console.log('URL:', leagueUrl);
    console.log('Tornei:', tournamentIds);
    
    // Importa PlaywrightScraper dal backend
    const { default: PlaywrightScraper } = await import('../utils/playwrightScraper.js');
    const scraper = new PlaywrightScraper();
    
    const batchResults = [];
    let successCount = 0;
    let errorCount = 0;
    
    try {
      // Inizializza il browser una sola volta per tutti i tornei
      await scraper.init();
      
      // Login una sola volta
      const loginSuccess = await scraper.login(username, password);
      if (!loginSuccess) {
        throw new Error('Login fallito per tutti i tornei');
      }
      
      // Scraping per ogni torneo
      for (let i = 0; i < tournamentIds.length; i++) {
        const tournamentId = tournamentIds[i];
        
        console.log(`Scraping torneo ${i + 1}/${tournamentIds.length}: ${tournamentId}`);
        
        try {
          // Seleziona il torneo
          await scraper.selectTournament(tournamentId);
          
          // Esegui lo scraping
          const results = await scraper.scrapeLeague(
            leagueUrl,
            scrapingUrls,
            { username, password },
            tournamentId,
            lega_id
          );
          
          if (results && results.rose) {
            successCount++;
            batchResults.push({
              tournamentId,
              success: true,
              data: results,
              summary: {
                squadre: results.rose.length,
                giocatori: results.rose.reduce((total, squadra) => total + (squadra.giocatori?.length || 0), 0)
              }
            });
            
            console.log(`‚úÖ Torneo ${tournamentId} completato: ${results.rose.length} squadre`);
          } else {
            errorCount++;
            batchResults.push({
              tournamentId,
              success: false,
              error: 'Nessun dato estratto'
            });
            console.log(`‚ùå Torneo ${tournamentId} fallito: nessun dato`);
          }
          
        } catch (tournamentError) {
          errorCount++;
          batchResults.push({
            tournamentId,
            success: false,
            error: tournamentError.message
          });
          console.log(`‚ùå Errore torneo ${tournamentId}: ${tournamentError.message}`);
        }
        
        // Pausa tra le richieste
        if (i < tournamentIds.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 3000));
        }
      }
      
      await scraper.close();
      
      const message = `Scraping batch completato: ${successCount} successi, ${errorCount} errori su ${tournamentIds.length} tornei`;
      
      res.json({ 
        success: successCount > 0,
        message: message,
        data: batchResults,
        summary: {
          total: tournamentIds.length,
          success: successCount,
          errors: errorCount
        }
      });
      
    } catch (scrapingError) {
      await scraper.close();
      console.error('‚ùå Errore durante lo scraping batch:', scrapingError);
      res.json({ 
        success: false,
        error: 'Errore durante lo scraping batch: ' + scrapingError.message,
        data: batchResults
      });
    }
    
  } catch (error) {
    console.error('‚ùå Errore generale scraping batch:', error);
    res.json({ 
      success: false,
      error: 'Errore durante lo scraping batch: ' + error.message
    });
  }
});

// Scraping classifica con Playwright
router.post('/playwright-classifica', requireAuth, async (req, res) => {
    try {
        const { lega_id, leagueUrl, username, password, tournamentId } = req.body;
        
        if (!lega_id || !leagueUrl || !username || !password) {
            return res.status(400).json({
                success: false,
                message: 'lega_id, leagueUrl, username e password sono obbligatori'
            });
        }

        console.log('üèÜ Scraping classifica con Playwright per lega:', lega_id);
        console.log('URL:', leagueUrl);

        // Recupera il tipo di lega dal database
        const legaInfo = await new Promise((resolve, reject) => {
            db.get(
                'SELECT tipo_lega FROM leghe WHERE id = ?',
                [lega_id],
                (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                }
            );
        });

        if (!legaInfo) {
            return res.status(400).json({
                success: false,
                message: 'Lega non trovata nel database'
            });
        }

        const scraper = new PlaywrightScraper();
        
        try {
            // Inizializza il browser
            if (!await scraper.init()) {
                throw new Error('Impossibile inizializzare Playwright');
            }

            // Imposta il tipo di lega dal database e l'URL
            scraper.setLeagueType(legaInfo.tipo_lega, leagueUrl);

            // Login
            const loginSuccess = await scraper.login(username, password, leagueUrl);
            if (!loginSuccess) {
                throw new Error('Login fallito');
            }

            // Seleziona il torneo se specificato
            if (tournamentId) {
                await scraper.selectTournament(tournamentId);
            }

            // Costruisci l'URL della classifica in modo pi√π flessibile
            let classificaUrl;
            if (legaInfo.tipo_lega === 'euroleghe') {
                // Per Euroleghe Mantra, prova diversi formati di URL
                const baseUrl = leagueUrl.replace(/\/$/, ''); // Rimuovi slash finale
                const tournamentParam = tournamentId ? `?id=${tournamentId}` : '';
                
                // Prova diversi formati di URL per la classifica
                const possibleUrls = [
                    `${baseUrl}/classifica${tournamentParam}`,
                    `${baseUrl}/classifica/${tournamentId || ''}`,
                    `${baseUrl}/ranking${tournamentParam}`,
                    `${baseUrl}/posizioni${tournamentParam}`,
                    `${baseUrl}/classifica`
                ];
                
                console.log('URL possibili per la classifica:', possibleUrls);
                classificaUrl = possibleUrls[0]; // Usa il primo formato come default
            } else {
                // Per Serie A Classic, usa il formato standard
                const baseUrl = leagueUrl.replace(/\/$/, ''); // Rimuovi slash finale
                classificaUrl = `${baseUrl}/classifica${tournamentId ? `?id=${tournamentId}` : ''}`;
            }
            
            console.log('URL classifica finale:', classificaUrl);
            
            // Esegui lo scraping della classifica
            const classifica = await scraper.scrapeClassifica(classificaUrl);
            
            // Salva nel database
            if (classifica && Array.isArray(classifica) && classifica.length > 0) {
                const dbResult = await scraper.saveClassificaToDatabase(lega_id, classifica);
                console.log('‚úÖ Classifica salvata nel database:', dbResult);
            }

            await scraper.close();

            res.json({
                success: true,
                classifica: classifica,
                posizioni_trovate: classifica ? classifica.length : 0,
                tipo_lega: scraper.tipoLega
            });

        } catch (error) {
            await scraper.close();
            throw error;
        }

    } catch (error) {
        console.error('‚ùå Errore scraping classifica:', error);
        res.status(500).json({
            success: false,
            message: error.message || 'Errore durante lo scraping della classifica'
        });
    }
});

// Scraping formazioni con Playwright
router.post('/playwright-formazioni', requireAuth, async (req, res) => {
    try {
        const { lega_id, leagueUrl, username, password, tournamentId, giornata } = req.body;
        
        if (!lega_id || !leagueUrl || !username || !password) {
            return res.status(400).json({
                success: false,
                message: 'lega_id, leagueUrl, username e password sono obbligatori'
            });
        }

        console.log('‚öΩ Scraping formazioni con Playwright per lega:', lega_id);
        console.log('URL:', leagueUrl);
        console.log('Giornata:', giornata || 'non specificata');

        // Recupera il tipo di lega dal database
        const legaInfo = await new Promise((resolve, reject) => {
            db.get(
                'SELECT tipo_lega FROM leghe WHERE id = ?',
                [lega_id],
                (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                }
            );
        });

        if (!legaInfo) {
            return res.status(400).json({
                success: false,
                message: 'Lega non trovata nel database'
            });
        }

        const scraper = new PlaywrightScraper();
        
        try {
            // Inizializza il browser
            if (!await scraper.init()) {
                throw new Error('Impossibile inizializzare Playwright');
            }

            // Imposta il tipo di lega dal database e l'URL
            scraper.setLeagueType(legaInfo.tipo_lega, leagueUrl);

            // Login
            const loginSuccess = await scraper.login(username, password, leagueUrl);
            if (!loginSuccess) {
                throw new Error('Login fallito');
            }

            // Seleziona il torneo se specificato
            if (tournamentId) {
                await scraper.selectTournament(tournamentId);
            }

            // Costruisci l'URL delle formazioni
            const formazioniUrl = `${leagueUrl}/formazioni${tournamentId ? `?id=${tournamentId}` : ''}`;
            
            // Esegui lo scraping delle formazioni
            const formazioni = await scraper.scrapeFormazioni(formazioniUrl, giornata);
            
            // Salva nel database
            if (formazioni && Array.isArray(formazioni) && formazioni.length > 0) {
                const dbResult = await scraper.saveFormazioniToDatabase(lega_id, formazioni);
                console.log('‚úÖ Formazioni salvate nel database:', dbResult);
            }

            await scraper.close();

            res.json({
                success: true,
                formazioni: formazioni,
                formazioni_trovate: formazioni ? formazioni.length : 0,
                giornata: giornata || 'non specificata',
                tipo_lega: scraper.tipoLega
            });

        } catch (error) {
            await scraper.close();
            throw error;
        }

    } catch (error) {
        console.error('‚ùå Errore scraping formazioni:', error);
        res.status(500).json({
            success: false,
            message: error.message || 'Errore durante lo scraping delle formazioni'
        });
    }
});

// Scraping completo (rose + classifica + formazioni) con Playwright
router.post('/playwright-completo', requireAuth, async (req, res) => {
    try {
        const { lega_id, leagueUrl, username, password, tournamentId, giornata } = req.body;
        
        if (!lega_id || !leagueUrl || !username || !password) {
            return res.status(400).json({
                success: false,
                message: 'lega_id, leagueUrl, username e password sono obbligatori'
            });
        }

        console.log('üîÑ Scraping completo con Playwright per lega:', lega_id);
        console.log('URL:', leagueUrl);
        console.log('Torneo:', tournamentId || 'non specificato');
        console.log('Giornata:', giornata || 'non specificata');

        // Recupera il tipo di lega dal database
        const legaInfo = await new Promise((resolve, reject) => {
            db.get(
                'SELECT tipo_lega FROM leghe WHERE id = ?',
                [lega_id],
                (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                }
            );
        });

        if (!legaInfo) {
            return res.status(400).json({
                success: false,
                message: 'Lega non trovata nel database'
            });
        }

        const scraper = new PlaywrightScraper();
        
        try {
            // Costruisci gli URL di scraping
            const baseUrl = leagueUrl.replace(/\/$/, '');
            const tournamentParam = tournamentId ? `?id=${tournamentId}` : '';
            
            const scrapingUrls = {
                rose: `${baseUrl}/rose${tournamentParam}`,
                classifica: `${baseUrl}/classifica${tournamentParam}`,
                formazioni: `${baseUrl}/formazioni${tournamentParam}`
            };

            console.log('URL di scraping:', scrapingUrls);

            // Esegui lo scraping completo
            const results = await scraper.scrapeLeague(
                leagueUrl,
                scrapingUrls,
                { username, password },
                tournamentId,
                lega_id
            );

            await scraper.close();

            res.json({
                success: true,
                results: results,
                summary: {
                    squadre_trovate: results.rose ? results.rose.length : 0,
                    giocatori_totali: results.rose ? results.rose.reduce((total, squadra) => total + (squadra.giocatori?.length || 0), 0) : 0,
                    posizioni_classifica: results.classifica ? results.classifica.length : 0,
                    formazioni_trovate: results.formazioni ? results.formazioni.length : 0
                },
                tipo_lega: results.tipo_lega,
                torneo_selezionato: results.torneo_selezionato
            });

        } catch (error) {
            await scraper.close();
            throw error;
        }

    } catch (error) {
        console.error('‚ùå Errore scraping completo:', error);
        res.status(500).json({
            success: false,
            message: error.message || 'Errore durante lo scraping completo'
        });
    }
});

// Ottieni tornei disponibili per una lega
router.post('/tournaments', requireAuth, async (req, res) => {
    try {
        const { lega_id, leagueUrl, username, password } = req.body;
        if (!lega_id || !leagueUrl || !username || !password) {
            return res.status(400).json({
                success: false,
                message: 'lega_id, leagueUrl, username e password sono obbligatori'
            });
        }
        // Recupera il tipo di lega dal database
        const legaInfo = await new Promise((resolve, reject) => {
            db.get(
                'SELECT tipo_lega FROM leghe WHERE id = ?',
                [lega_id],
                (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                }
            );
        });
        if (!legaInfo) {
            return res.status(400).json({
                success: false,
                message: 'Lega non trovata nel database'
            });
        }
        const scraper = new PlaywrightScraper();
        try {
            await scraper.init();
            scraper.setLeagueType(legaInfo.tipo_lega, leagueUrl);
            const loginSuccess = await scraper.login(username, password, leagueUrl);
            if (!loginSuccess) {
                await scraper.close();
                return res.status(401).json({ success: false, message: 'Login fallito' });
            }
            const tournaments = await scraper.getAvailableTournaments();
            await scraper.close();
            res.json({ success: true, tournaments });
        } catch (error) {
            await scraper.close();
            throw error;
        }
    } catch (error) {
        console.error('‚ùå [TOURNAMENTS] Errore:', error);
        res.status(500).json({ success: false, message: error.message || 'Errore durante il recupero tornei' });
    }
});

// Scraping multiplo per pi√π tornei
router.post('/scraping-multiplo', requireAuth, async (req, res) => {
  try {
    const { urls, lega_id, tipo } = req.body; // urls: [{torneo_id, url, nome}], tipo: 'classifica' | 'formazioni' | ...
    if (!urls || !Array.isArray(urls) || !lega_id || !tipo) {
      return res.status(400).json({ error: 'urls, lega_id e tipo richiesti' });
    }
    const results = {};
    for (const torneo of urls) {
      let data = null;
      if (tipo === 'classifica') {
        data = await scrapeClassifica(torneo.url);
      } else if (tipo === 'formazioni') {
        data = await scrapeFormazioni(torneo.url);
      } // aggiungi altri tipi se servono
      results[torneo.nome || torneo.torneo_id] = data;
    }
    res.json({ success: true, results });
  } catch (error) {
    console.error('Errore scraping multiplo:', error);
    res.status(500).json({ error: 'Errore scraping multiplo', details: error.message });
    }
});

// API per salvare i tornei preferiti
router.post('/preferiti/salva', requireAuth, async (req, res) => {
  try {
    const { lega_id, tornei } = req.body; // tornei: [{id, name, url}]
    const utente_id = req.user.id;
    
    if (!lega_id || !tornei || !Array.isArray(tornei)) {
      return res.status(400).json({ 
        success: false, 
        message: 'lega_id e tornei (array) sono obbligatori' 
      });
    }

    console.log(`üíæ Salvataggio tornei preferiti per utente ${utente_id}, lega ${lega_id}`);
    console.log(`üìã Tornei da salvare:`, tornei);

    // Prima rimuovi tutti i tornei preferiti esistenti per questa lega e utente
    await new Promise((resolve, reject) => {
      db.run(
        'DELETE FROM tornei_preferiti WHERE utente_id = ? AND lega_id = ?',
        [utente_id, lega_id],
        (err) => {
          if (err) reject(err);
          else resolve();
        }
      );
    });

    // Poi inserisci i nuovi tornei preferiti
    const insertPromises = tornei.map(torneo => {
      return new Promise((resolve, reject) => {
        db.run(
          'INSERT INTO tornei_preferiti (utente_id, lega_id, torneo_id, torneo_nome, torneo_url) VALUES (?, ?, ?, ?, ?)',
          [utente_id, lega_id, torneo.id, torneo.name, torneo.url || null],
          function(err) {
            if (err) reject(err);
            else resolve(this.lastID);
          }
        );
      });
    });

    await Promise.all(insertPromises);

    console.log(`‚úÖ Salvati ${tornei.length} tornei preferiti`);

    res.json({
      success: true,
      message: `Salvati ${tornei.length} tornei preferiti`,
      tornei_salvati: tornei.length
    });

  } catch (error) {
    console.error('‚ùå Errore salvataggio tornei preferiti:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Errore durante il salvataggio dei tornei preferiti'
    });
  }
});

// API per caricare i tornei preferiti
router.get('/preferiti/:lega_id', requireAuth, async (req, res) => {
  try {
    const { lega_id } = req.params;
    const utente_id = req.user.id;

    console.log(`üìÇ Caricamento tornei preferiti per utente ${utente_id}, lega ${lega_id}`);

    const tornei = await new Promise((resolve, reject) => {
      db.all(
        'SELECT torneo_id, torneo_nome, torneo_url, created_at FROM tornei_preferiti WHERE utente_id = ? AND lega_id = ? ORDER BY created_at ASC',
        [utente_id, lega_id],
        (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        }
      );
    });

    console.log(`‚úÖ Caricati ${tornei.length} tornei preferiti`);

    res.json({
      success: true,
      tornei: tornei.map(t => ({
        id: t.torneo_id,
        name: t.torneo_nome,
        url: t.torneo_url
      })),
      count: tornei.length
    });

  } catch (error) {
    console.error('‚ùå Errore caricamento tornei preferiti:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Errore durante il caricamento dei tornei preferiti'
    });
  }
});

// API per rimuovere un torneo preferito
router.delete('/preferiti/:lega_id/:torneo_id', requireAuth, async (req, res) => {
  try {
    const { lega_id, torneo_id } = req.params;
    const utente_id = req.user.id;

    console.log(`üóëÔ∏è Rimozione torneo preferito: utente ${utente_id}, lega ${lega_id}, torneo ${torneo_id}`);

    const result = await new Promise((resolve, reject) => {
      db.run(
        'DELETE FROM tornei_preferiti WHERE utente_id = ? AND lega_id = ? AND torneo_id = ?',
        [utente_id, lega_id, torneo_id],
        function(err) {
          if (err) reject(err);
          else resolve(this.changes);
        }
      );
    });

    if (result > 0) {
      console.log(`‚úÖ Torneo preferito rimosso`);
      res.json({
        success: true,
        message: 'Torneo preferito rimosso con successo'
      });
    } else {
      res.status(404).json({
        success: false,
        message: 'Torneo preferito non trovato'
      });
    }

  } catch (error) {
    console.error('‚ùå Errore rimozione torneo preferito:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Errore durante la rimozione del torneo preferito'
    });
  }
});

export default router; 